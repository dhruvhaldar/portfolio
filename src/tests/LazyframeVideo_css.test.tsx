import { render, screen } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';
import LazyframeVideo from '@/components/LazyframeVideo';

// Mock lazyframe since we are testing component rendering, not the library itself
const { mockLazyframe } = vi.hoisted(() => {
  return { mockLazyframe: vi.fn() };
});

vi.mock('lazyframe', () => ({
  default: mockLazyframe
}));

// Mock the security utility to bypass isSafeImageSrc check
// This allows us to test the CSS sanitization logic even with "unsafe" inputs
vi.mock('@/app/utils/security', async (importOriginal) => {
  const actual = await importOriginal<typeof import('@/app/utils/security')>();
  return {
    ...actual,
    isSafeImageSrc: vi.fn(),
  };
});

// Import the mocked module to control the mock implementation
import { isSafeImageSrc } from '@/app/utils/security';

describe('LazyframeVideo CSS Injection Prevention', () => {
  beforeEach(() => {
    // By default, allow all images in these tests to reach the CSS sanitization logic
    vi.mocked(isSafeImageSrc).mockReturnValue(true);
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should properly escape special characters in thumbnail URL for CSS context', () => {
    // Attempt to inject a new CSS property (color: red) by breaking out of url()
    // Note: The closing parenthesis matches the opening one of url(
    // The semicolon terminates the property.
    // The trailing stuff is to consume any trailing closing parenthesis generated by the component template.
    const maliciousSrc = "https://example.com/image.jpg); color: red; --";
    const videoSrc = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";

    const { container } = render(<LazyframeVideo src={videoSrc} thumbnail={maliciousSrc} />);

    const lazyframeDiv = container.querySelector('.lazyframe') as HTMLElement;
    expect(lazyframeDiv).toBeInTheDocument();

    console.log('Lazyframe style:', lazyframeDiv.getAttribute('style'));

    // Before fix: JSDOM might parse `color: red` as a valid property if injection succeeds
    // After fix: The URL is quoted, so `); color: red; --` becomes part of the URL string.

    // Check if `color: red` is applied as a style property
    // If injection worked, lazyframeDiv.style.color should be 'red'
    // If fix is working, it should NOT be 'red'
    expect(lazyframeDiv.style.color).not.toBe('red');

    // Also check that backgroundImage is preserved and quoted
    // The malicious string should be INSIDE the url("...")
    // JSDOM might serialize it.

    // Note: JSDOM/browsers might drop the property if the URL inside url() is invalid or weird,
    // but if we quote it properly, it should be valid string.
    // However, `https://example.com/image.jpg); color: red; --` is a weird URL but valid string.

    // We assert that we have a background-image
    expect(lazyframeDiv.style.backgroundImage).toBeTruthy();
    expect(lazyframeDiv.style.backgroundImage).toContain('url(');

    // Ensure the malicious part is now safely inside the URL string (and likely encoded)
    // Our fix encodes characters, so verify that encoded chars are present
    expect(lazyframeDiv.style.backgroundImage).toContain('%29'); // Encoded ')'
    // encodeURI does NOT encode ';', ':', ' ', etc.
    // So "color: red" might still be visible as text, but inside the string due to quotes.

    // Let's verify our specific replacements
    expect(lazyframeDiv.style.backgroundImage).toContain('%29'); // ) -> %29
  });

  it('should handle quotes in thumbnail URL safely', () => {
    const quoteSrc = 'https://example.com/image.jpg?q="foo"';
    const videoSrc = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";

    const { container } = render(<LazyframeVideo src={videoSrc} thumbnail={quoteSrc} />);
    const lazyframeDiv = container.querySelector('.lazyframe') as HTMLElement;

    console.log('Lazyframe quote style:', lazyframeDiv.getAttribute('style'));

    // Verify the background image is set
    expect(lazyframeDiv.style.backgroundImage).toContain('example.com');
    // Verify quotes are handled (either encoded or inside the string)
    // With our fix, it should be url('...%22...') or similar if we were encoding "
    // Actually we only replace ' (single quote). Double quote " is not replaced by our manual replace,
    // but `encodeURI` handles double quotes!
    // encodeURI('"') -> "%22"
    expect(lazyframeDiv.style.backgroundImage).toContain('%22');
  });
});
